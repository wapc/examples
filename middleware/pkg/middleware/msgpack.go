// Code generated by @apexlang/codegen. DO NOT EDIT.

package middleware

import (
	"github.com/wapc/tinygo-msgpack"
	"github.com/wapc/tinygo-msgpack/convert"
)

var _ = convert.Package

func (o *Config) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		_, err := decoder.ReadString()
		if err != nil {
			return err
		}
		err = decoder.Skip()
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Config) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(0)

	return nil
}

func (o *HttpRequest) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "method":
			o.Method, err = decoder.ReadString()
		case "uri":
			o.URI, err = decoder.ReadString()
		case "headers":
			mapSize, err := decoder.ReadMapSize()
			if err != nil {
				return err
			}
			o.Headers = make(Headers, mapSize)
			for mapSize > 0 {
				mapSize--
				key, err := decoder.ReadString()
				if err != nil {
					return err
				}
				listSize, err := decoder.ReadArraySize()
				if err != nil {
					return err
				}
				value := make([]string, 0, listSize)
				for listSize > 0 {
					listSize--
					var nonNilItem string
					nonNilItem, err = decoder.ReadString()
					if err != nil {
						return err
					}
					value = append(value, nonNilItem)
				}
				if err != nil {
					return err
				}
				o.Headers[key] = value
			}
		case "body":
			o.Body, err = decoder.ReadNillableByteArray()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *HttpRequest) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(4)
	encoder.WriteString("method")
	encoder.WriteString(o.Method)
	encoder.WriteString("uri")
	encoder.WriteString(o.URI)
	encoder.WriteString("headers")
	encoder.WriteMapSize(uint32(len(o.Headers)))
	if o.Headers != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Headers {
			encoder.WriteString(k)
			encoder.WriteArraySize(uint32(len(v)))
			for _, v := range v {
				encoder.WriteString(v)
			}
		}
	}
	encoder.WriteString("body")
	encoder.WriteNillableByteArray(o.Body)

	return nil
}

func (o *HttpResponse) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "uri":
			o.URI, err = decoder.ReadString()
		case "request":
			err = o.Request.Decode(decoder)
		case "response":
			err = o.Response.Decode(decoder)
		case "status":
			o.Status, err = decoder.ReadUint16()
		case "body":
			o.Body, err = decoder.ReadNillableByteArray()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *HttpResponse) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(5)
	encoder.WriteString("uri")
	encoder.WriteString(o.URI)
	encoder.WriteString("request")
	o.Request.Encode(encoder)
	encoder.WriteString("response")
	o.Response.Encode(encoder)
	encoder.WriteString("status")
	encoder.WriteUint16(o.Status)
	encoder.WriteString("body")
	encoder.WriteNillableByteArray(o.Body)

	return nil
}

func (o *Set) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "setHeaders":
			mapSize, err := decoder.ReadMapSize()
			if err != nil {
				return err
			}
			o.SetHeaders = make(Headers, mapSize)
			for mapSize > 0 {
				mapSize--
				key, err := decoder.ReadString()
				if err != nil {
					return err
				}
				listSize, err := decoder.ReadArraySize()
				if err != nil {
					return err
				}
				value := make([]string, 0, listSize)
				for listSize > 0 {
					listSize--
					var nonNilItem string
					nonNilItem, err = decoder.ReadString()
					if err != nil {
						return err
					}
					value = append(value, nonNilItem)
				}
				if err != nil {
					return err
				}
				o.SetHeaders[key] = value
			}
		case "removeHeaders":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.RemoveHeaders = make([]string, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem string
				nonNilItem, err = decoder.ReadString()
				if err != nil {
					return err
				}
				o.RemoveHeaders = append(o.RemoveHeaders, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Set) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("setHeaders")
	encoder.WriteMapSize(uint32(len(o.SetHeaders)))
	if o.SetHeaders != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.SetHeaders {
			encoder.WriteString(k)
			encoder.WriteArraySize(uint32(len(v)))
			for _, v := range v {
				encoder.WriteString(v)
			}
		}
	}
	encoder.WriteString("removeHeaders")
	encoder.WriteArraySize(uint32(len(o.RemoveHeaders)))
	for _, v := range o.RemoveHeaders {
		encoder.WriteString(v)
	}

	return nil
}
